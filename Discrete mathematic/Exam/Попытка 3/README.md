# Попытка №3

## Задача №1.

### Сортировка слиянием подпоследовательностей

Реализуйте алгоритм сортировки слиянием подпоследовательностей произвольных данных в функции
```go
func MergeSeqSort(nitems int, compare func(i, j int) int, indices chan int)
```
которая выводит в канал ```indices``` индексы чисел, отсортированных по возрастанию.

Функция должна использовать каналы, go-программы и алгоритм сортировки слиянием подпоследовательностей.

Функция ```compare``` возвращает отрицательное значение, если элемент по индексу ```i``` меньше элемента по индексу ```j```, ноль, если они равны и положительное значение, если больше.

```nitems``` — количество сортируемых элементов, допустимые индексы для функции compare лежат в диапазоне от 0 до ```nitems - 1``` включительно.

Каналы должны быть !!!**синхронными**!!!. Функция должна закрывать канал после вывода индексов.

### Алгоритм сортировки слиянием подпоследовательностей
 * Сортировка слиянием подпоследовательностей стабильная, т.е. если для пары индексов функция ```compare``` вернула ноль, то в выходной канал меньший индекс должен быть записан раньше.
 * Это итеративный алгоритм, рекурсия в нём не требуется.
 * Внешний цикл оперирует последовательностью (массивом, списком, каналом) последовательностей сортируемых элементов (в этой задаче: синхронных каналов индексов ```chan int```).На каждой итерации внешнего цикла длина этой последовательности сокращается вдвое путём попарного слияния соседних подпоследовательностей (в случае нечётной длины последняя непарная просто передаётся на следующую итерацию).
 * Последовательность последовательностей инициализируется как последовательность длины ```nitems``` последовательностей длины 1. Внешний цикл продолжается до тех пор, пока длина последовательности не меньше двух, соответственно, после завершения внешнего цикла получим последовательность длины 1, содержащую единственную последовательность длины ```nitems``` — она будет искомой отсортированной последовательностью.
### Пример. 
Отсортируем последовательность слов
```
quick brown fox jumps over the lazy dog
```

по возрастанию длин слов.

Подпоследовательности будем разделять точкой с запятой:
```
quick;brown;fox;jumps;over;the;lazy;dog
quick brown;fox jumps;the over;dog lazy
fox quick brown jumps;the dog over lazy
fox the dog over lazy quick brown jumps
```

Обратите внимание, что сортировка стабильная — слова равной длины при слиянии сохраняют свой относительный порядок.

### Пересдача
  * Тем, кто решил эту задачу через асинхронные каналы ```(make(chan int, n))```, нужно перерешать через синхронные (создаются ```make(chan int)```);
  * тем, у кого задача отклонена из-за плагиата, нужно перерешать, используя канал каналов для представления внешней последовательности, этот канал каналов может быть асинхронным (создаётся ```make(chan chan int, nitems)```).

### Рекомендация
  * Функция слияния принимает три канала: два источника и один целевой.
  * В этой задаче тесты генерируются для штатных модульных тестов языка Go: https://pkg.go.dev/testing, https://habr.com/ru/companies/otus/articles/739468/.

## Задача №2.

## Сильно регулярные грамматики

### Определение
**Сильно регулярная грамматика** — подкласс контекстно-свободных грамматик, описывающих регулярный язык. Определяется он следующим образом.

Пусть в грамматике есть два нетерминала, M и N (это могут быть как два разных, так и один и тот же нетерминал), такие что из M можно вывести цепочку, содержащую N и наоборот:

```
M⇒*…N…

N⇒*…M…
```
Мы будем называть такие нетерминалы взаимно-рекурсивными (рекурсивный нетерминал будет взаимно-рекурсивен сам себе).

Отношение взаимной рекурсивности есть отношение эквивалентности, и оно делит нетерминалы на классы эквивалентности.

Назовём правило (продукцию) грамматики леворекурсивным, если оно содержит вхождение (взаимно)рекурсивного нетерминала только в крайне левой позиции:
```
M → N…
```
Аналогично для праворекурсивного правила: ```M → …N```.

Грамматика называется **сильно регулярной**, если каждый класс эквивалентности взаимно-рекурсивных нетерминалов содержит либо только праворекурсивные правила, либо только леворекурсивные.

### Алгоритм проверки грамматики на сильную регулярность
  1. Построим граф, в вершинах которого находятся нетерминалы, а дуги задаются следующим образом: дуга из вершины X ведёт в вершину Y только если в грамматике имеется продукция X → …Y….
  2. Выделим компоненты сильной связности в нём — они, очевидно, будут соответствовать классам эквивалентности взаимно-рекурсивных нетерминалов.
  3. Для каждой компоненты связности правила, содержащие (взаимно)рекурсивные вхождения нетерминалов, должны быть либо все леворекурсивными, либо все праворекурсивными.
     
### Входные и выходные данные

На вход подаётся грамматика в следующем виде:
```
N A
A->bCDefG
A->hiJ
C->kLMn
…
```
где N — число правил грамматики, A — аксиома грамматики. Нетерминальные символы обозначаются заглавными буквами алфавита, терминальные — строчными. Гарантируется, что любой нетерминал прямо или косвенно достижим из аксиомы.

На выход следует вывести ```yes```, если грамматика сильно регулярная, и ```no``` в противном случае.

### Пример
Возьмём пример из дополнительной литературы [1]:
```
3 Z
Z->XY
X->aY
Y->bX
Y->c
```
Эта грамматика сильно регулярная, содержит две сильно связанные компоненты: {X, Y} и {Z}. В первой компоненте рекурсия правая, вторая вообще не рекурсивна. Следовательно, эта грамматика сильно регулярная, нужно выдать ответ «yes».

(Про то, как выглядит конечный автомат для этой грамматике, можно посмотреть в дополнительной литературе.)

### Дополнительная литература:
  1. Harikrishna N., Shalini K. Regular approximation of CFGs, 2010
### Java
ри решении задачи на Java главный класс должен называться StronglyRegular.

## Задача №3.

### Композиция автоматов Мили и ДКА
Дан инициальный автомат Мили AM = ⟨Q_M, X, Y, δ_M, ϕ, q0_M⟩ и детерминированный конечный автомат AR = ⟨Q_R, Y, δ_R, F, q0_R⟩, причём выходной алфавит автомата Мили совпадает с входным алфавитом распознающего автомата. Оба алфавита — строчные латинские буквы.

Эти два автомата связаны в цепочку (см фото):
![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/19bb76c7-3808-4f05-8f4e-4816e5b63f9c)

Следует найти длину кратчайшей цепочки на входе автомата Мили, которая переводит распознающий автомат в заключительное состояние.

На вход программе передаётся сначала описание автомата Мили в формате
```
N1 Mx q01
q … q
…
q … q
y … y
…
y … y

N2 My q02
s q … q
…
s q … q
```
где Mx — размер входного алфавита 1 ≤ |X| ≤ 26, N1 — число состояний автомата Мили, q01 — начальное состояние автомата Мили, My — размер выходного алфавита автомата Мили и входного алфавита распознающего автомата, N2 — число состояний распознающего автомата 1 ≤ |Y| ≤ 26, q02 — начальное состояние распознающего автомата.

После чисел Mx N1 q01 записывается матрица переходов и матрица выходов автомата Мили, после чисел My N2 q02 описыываются состоятия ДКА в формате s q … q, где s — признак заключительности (+ — заключительное, - — нет), а q — переходы.

Программа должна печатать длину кратчайшей цепочки, либо none, если заключительное состояние недостижимо.

### Java
При решении задачи на Java главный класс должен называться MealyDFA.
