# Попытка №2

## Задача №1.

### Сортировка слиянием подпоследовательностей

Реализуйте алгоритм сортировки слиянием подпоследовательностей произвольных данных в функции
```go
func MergeSeqSort(nitems int, compare func(i, j int) int, indices chan int)
```
которая выводит в канал ```indices``` индексы чисел, отсортированных по возрастанию.

Функция должна использовать каналы, go-программы и алгоритм сортировки слиянием подпоследовательностей.

Функция ```compare``` возвращает отрицательное значение, если элемент по индексу ```i``` меньше элемента по индексу ```j```, ноль, если они равны и положительное значение, если больше.

```nitems``` — количество сортируемых элементов, допустимые индексы для функции compare лежат в диапазоне от 0 до ```nitems - 1``` включительно.

Каналы должны быть !!!**синхронными**!!!. Функция должна закрывать канал после вывода индексов.

### Алгоритм сортировки слиянием подпоследовательностей
 * Сортировка слиянием подпоследовательностей стабильная, т.е. если для пары индексов функция ```compare``` вернула ноль, то в выходной канал меньший индекс должен быть записан раньше.
 * Это итеративный алгоритм, рекурсия в нём не требуется.
 * Внешний цикл оперирует последовательностью (массивом, списком, каналом) последовательностей сортируемых элементов (в этой задаче: синхронных каналов индексов ```chan int```).На каждой итерации внешнего цикла длина этой последовательности сокращается вдвое путём попарного слияния соседних подпоследовательностей (в случае нечётной длины последняя непарная просто передаётся на следующую итерацию).
 * Последовательность последовательностей инициализируется как последовательность длины ```nitems``` последовательностей длины 1. Внешний цикл продолжается до тех пор, пока длина последовательности не меньше двух, соответственно, после завершения внешнего цикла получим последовательность длины 1, содержащую единственную последовательность длины ```nitems``` — она будет искомой отсортированной последовательностью.
### Пример. 
Отсортируем последовательность слов
```
quick brown fox jumps over the lazy dog
```

по возрастанию длин слов.

Подпоследовательности будем разделять точкой с запятой:
```
quick;brown;fox;jumps;over;the;lazy;dog
quick brown;fox jumps;the over;dog lazy
fox quick brown jumps;the dog over lazy
fox the dog over lazy quick brown jumps
```

Обратите внимание, что сортировка стабильная — слова равной длины при слиянии сохраняют свой относительный порядок.

### Рекомендация
Функция слияния принимает три канала: два источника и один целевой.

В этой задаче тесты генерируются для штатных модульных тестов языка Go: https://pkg.go.dev/testing, https://habr.com/ru/companies/otus/articles/739468/.

## Задача №2.
### Компиляция Паскаля

Программа на Паскале состоит из нескольких исходных файлов с расширением ```.pas```. Один из файлов является «программой» (начинается с ключевого слова program), его компиляция приводит к порождению исполнимого файла с расширением ```.exe```, остальные «юнитами» (начинаются с ключевого слова ```unit```), их компиляция приводит к порождению файла с расширением ```.dcu```.

Каждый исходный файл может содержать секцию импорта (ключевое слово ```uses```), содержащую имена «юнитов», от которых файл зависит. 

Пример импорта в «программе»:
```
program main;
uses unit1, unit2, unit3, …;
…
```
Пример импорта в «юните»:
```
unit unit1;
interface
uses unit2, unit3, unit4, …;
…
```
В именах в секции ```uses``` расширение не указывается.
Когда компилятор встречает имя «юнита» в секции ```uses```, он загружает из соответствующего ```.dcu``` файла информацию о его интерфейсе, при необходимости перекомпилируя его (создавая новый ```.dcu``` для ```.pas```).

Перекомпиляция «юнита» выполняется в следующих случаях:
 * файл ```.dcu``` для «юнита» отстутствует,
 * файл ```.dcu``` имеет более раннюю временну́ю метку, чем одноимённый файл ```.pas``` (т.е. пользователь редактировал файл после последней компиляции),
 * один из «юнитов» в секции ```uses``` был перекомпилирован.
   
Таким образом, редактирование одного из «юнитов» (или удаление соответствующего ```.dcu```-файла) может привести к каскадной перекомпиляции всех «юнитов», которые зависят от данного прямо или транзитивно.
Файл «программы» перекомпилируется всегда.

Считаем, что в рассматриваемой реализации Паскаля циклический импорт запрещён, т.е. приводит к ошибке компиляции.

### Входные и выходные данные

Входные данные программы имеют вид
```
N
source1 k1 unit11 … unit1k1
…
sourceN kN unitN1 … unitNkN
M
filename1 timestamp1
…
filenameM timestampN
```
В первой строке указывается число ```N``` — количество исходных файлов, ```N``` > 1, т.к. файл-«программа» всегда присутствует, причём файл-«программа» всегда имеет имя ```main```.

Последующие ```N``` строчек содержат имя исходного файла (без расширения), число импортируемых «юнитов» ```ki``` и их имена (без расширения). Имена модулей могут содержать только буквы.

В следующей строке указывается число ```M``` — количество файлов в текущей папке, причём ```N``` ≤ ```M```≤ ```2N``` − 1, т.к. в папке присутсвуют все ```N``` исходников, среди которых один из них — «программа» ```main.pas```, для остальных «юнитов» соответствующий ```.dcu``` может либо присутствовать, либо отсутствовать.

Временна́я метка записывается как целое неотрицательное число.

Программа должна выводить имена исходных файлов, которые должны быть перекомпилированы, в алфавитном порядке. Если присутствуют циклические зависимости, то вместо имён файлов следует вывести ```!CYCLE```.

Пример входных данных:
```
6
parser    2 lexer syntree
lexer     0
main      3 parser semantic generator
generator 1 syntree
syntree   0
semantic  1 syntree
10
lexer.dcu     26
parser.pas    30
lexer.pas     21
syntree.pas   23
syntree.dcu   25
generator.dcu 20
semantic.pas  33
generator.pas 15
semantic.dcu  31
main.pas      28
```

Файлы ```lexer.pas``` и ```syntree.pas``` перекомпилированы не будут, т.к. соответствующие ```.dcu``` файлы были обновлены после их редактирования и обновлённых зависимостей у них нет.

Файл ```parser.pas``` будет перекомпилирован, т.к. соответствующего файла ```parser.dcu``` нет.

Файл ```semantic.pas``` будет перекомпилирован, т.к. он редактировался после предыдущей перекомпиляции — его временна́я метка больше метки файла ```semantic.dcu```.

Будет перекомпилирован файл ```generator.pas```, т.к. его зависимость — файл ```syntree.pas``` перекомпилировался позже (метка ```syntree.dcu``` — 25), чем ```generator.dcu``` (метка 20).
Файл ```main.pas``` будет перекомпилирован в любом случае.

Поэтому будут выведены следующие имена:
```
generator.pas
main.pas
parser.pas
semantic.pas
```

Граф зависимостей между входными файлами будет иметь вид
![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/aac41e4e-2b46-4464-8c81-7335d4b225d2)

Красным отмечены файлы, подлежащие перекомпиляции.

При написании программы на языке Java класс с функцией main должен называться PascalCompiler.


## Задача №3.

На вход программы подаётся распознающий автомат в формате
```
M N q0
s d … d
…
s d … d
```
где ```M``` — количество символов входного языка (1 ≤ ```M``` ≤ 26), ```N``` — количество состояний, ```q0``` — начальное состояние.

Последующие N строчек начинаются на знак ```+``` (заключительное состояние) или ```-``` (не заключительное) и ```M``` чисел — состояний, куда перейдёт автомат.

Символы входного алфавита — строчные латинские буквы, начиная с ```a```.

Если язык автомата конечный и непустой, то следует напечатать длину самого длинного слова в языке.

Если язык автомата пустой, то следует напечатать ```EMPTY```.

Если язык бесконечный, то следует напечатать ```INF```.

Пример. Для входных данных
```
3 8 5
+ 3 6 6
+ 2 7 4
+ 3 0 6
- 3 3 3
+ 7 6 6
+ 3 0 1
+ 3 3 3
+ 0 2 0
```
наибольшее слово будет иметь длину 6, к примеру, это будет слово ccabbb.

Граф этого автомата изображён на фото

![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/486da50c-4cc0-40da-a83b-65c6937c396e)
