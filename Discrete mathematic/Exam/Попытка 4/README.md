# Попытка №4

## Задача №1.

Реализуйте функцию слияния отсортированных последовательностей вещественных чисел в функции
```
func MergeSeqs(sources []chan float, target chan float)
```
которая принимает срез последовательностей sources и формирует в канале ```target``` результат слияния.

Последовательности отсортированы по возрастанию.

Функция слияния должна использовать очередь с приоритетами для выбора очередного наименьшего значения, таким образом, сложность работы алгоритма должна быть ```O(M ⋅ log N)```, где ```M``` — общее количество чисел во всех источниках, ```N``` — количество источников.
Допустимо использовать библиотечную очередь с приоритетами ```container/heap``` (https://pkg.go.dev/container/heap).

## Задача №2.

Сборка мусора — механизм языка программирования, обеспечивающий автоматическое освобождение динамической памяти, основанный на понятии достижимости объектов.

Считается, что объект, выделенный в динамической памяти, достижим, если существует такая цепочка объектов, которая начинается в переменной (глобальной или локальной) и заканчивается в данном объекте. Если такой цепочки не существует, то объект считается недостижимым и память, занятая им, освобождается.

Программа на модельном языке состоит из операций присваивания вида
```
‹цель›=‹значение›
```
где ```‹цель›``` — глобальная переменная или поле объекта, ```‹значение›``` — глобальная переменная, поле объекта, операция распределения памяти или нулевая ссылка.

  * В программе доступно 26 глобальных переменных с именами от a до z, которые могут хранить объекты. При старте программы каждая из них содержит нулевую ссылку.
  * Каждый объект содержит 26 полей с именами от a до z, которые могут хранить ссылки на другие объекты и поле id, хранящее идентификатор объекта.
  * Обращение к полю имеет вид ```‹пер›.‹поле›.….‹поле›```, где ```‹пер›``` — имя глобальной переменной, ```‹поле›``` — имена полей.
  * Операция распределения памяти имеет вид ```@‹ид›```, где ```‹ид›``` — идентификатор объекта (значение поля id). Поля a … z при создании инициализируются как нулевые ссылки.
  * Нулевая ссылка записывается как 0.
    
Таким образом, допустимая программа может выглядеть как
```
a=@1
b=@2
a.x=b
b.y=a
a.x.y.z=@3
a.x.y.z.t=@4
b.y.x.y.z.t.u=b
a.x=0
b.y.z=a
a=a.c
```
Следует написать программу, которая считывает из первой строки стандартного ввода количество присваиваний, затем каждое присваивание в отдельной строке, и выводит идентификаторы недостижимых объектов через пробел в порядке возрастания. 

Можно считать, что в корректной программе не встречаются пробелы, а также что идентификаторы являются последовательными натуральными числами.

Пример. Для входных данных
```
10
a=@1
b=@2
a.x=b
b.y=a
a.x.y.z=@3
a.x.y.z.t=@4
b.y.x.y.z.t.u=b
a.x=0
b.y.z=a
a=a.c
```
Программа должна выдать
```
3 4
```
Объект с идентификатором 2 хранится в переменной b, объект с идентификатором 1 достижим как b.y, объекты с идентификаторами 3 и 4 недостижимы.

### Java
При написании программы на Java главный класс должен иметь имя GCModel.


## Задача №3.

### Композиция автоматов Мили

Даны два инициальных автомата Мили ```A1 = ⟨Q1, X, Y, δ1, ϕ1, q01⟩``` и ```A2 = ⟨Q2, Y, Z, δ2, ϕ2, q02⟩```, причём выходной алфавит первого совпадает с входным алфавитом второго. Оба алфавита — строчные латинские буквы.

Эти два автомата связаны в цепочку (см фото):

![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/82513c00-61b1-4e35-8995-c4f2ad0a3e82)

Следует найти длину кратчайшей цепочки на входе автомата Мили, которая переводит распознающий автомат в заключительное состояние.

На вход программе передаётся сначала описание автомата Мили в формате
```
N1 Mx q01
q … q
…
q … q
y … y
…
y … y

N2 My q02
s q … q
…
s q … q
```
где N1 — число состояний первого автомата, Mx — размер входного алфавита 1 ≤ |X| ≤ 26, q01 — начальное состояние первого автомата, N2 — число состояний второго автомата, My — размер выходного алфавита пеарвого и входного алфавита второго автомата, 1 ≤ |Y| ≤ 26, q02 — начальное состояние второго автомата.

После троек чисел ```N1 Mx q01``` и ```N2 My q02``` записываются матрицы переходов и матрицы выходов обоих автоматов.

Программа должна расречатать автомат ```A12 = ⟨Q12, X, Z, δ12, ϕ12, q012⟩```, который эквивалентен композиции первых двух автоматов. Состояния нового автомата должны быть пронумерованы канонически (см. задачу Canonic).

### Java
При решении задачи на Java главный класс должен называться MealyMealy.
