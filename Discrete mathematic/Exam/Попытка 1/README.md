Попытка №1

##Задача №1.

Реализуйте алгоритм сортировки слиянием произвольных данных в функции
```go
func MergeSort(items int, compare func(i, j int) int, indices chan int)
```
которая выводит в канал ```indices``` индексы чисел, отсортированных по возрастанию. Функция должна использовать каналы, ```go```-программы и алгоритм сортировки слиянием.

Функция ```compare``` возвращает отрицательное значение, если элемент по индексу ```i``` меньше элемента по индексу ```j```, ноль, если они равны и положительное значение, если больше.

Каналы должны быть синхронными. Функция должна закрывать канал после вывода индексов.

#Рекомендация
    Рекурсивная функция сортировки принимает диапазон индексов, которые она затем выдаёт в отсортированном виде в канал.
    Функция слияния принимает три канала: два источника и один целевой.

Задача №2.
На вход программы поступает число n — количество курсов (пронумерованных от 1 до n) и описание каждого курса в виде k c1 … ck — перечень курсов, предшествующих данному (если курсу ничего не предшествует, то строка состоит из числа ноль).
Если курсы образуют циклические зависимости, то следует вывести слово cycle, иначе — минимальное количество семестров, требуемых для чтения этих курсов (считаем, что число курсов в семестре неограничено).
Например, входные данные


Copy code
10
0
1 1
1 2
1 3
1 4
1 4
1 6
1 7
0
3 3 5 9
соответствуют такому графу зависимостей курсов (тут картинка)

Очевидно, что потребуется 7 семестров.
Подсказка: можно, например, воспользоваться алгоритмом Беллмана-Форда.
![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/1f31a823-4c59-4a23-95a8-311e13711621)
![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/c06cb3b4-576d-48f5-b9f8-19bff6d3d439)
![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/531f27b4-6302-45c3-be51-a27772605ed0)


Задача №3.
Равенство автоматовНа вход программы подаются два распознающих автомата в формате
```go
M
N q0
s d … d
…
s d … d
N q0
s d … d
…
s d … d
```

где ```M``` — количество символов входного языка (1 ≤ M ≤ 26), ```N``` — количество состояний, ```q0``` — начальное состояние.
Последующие ```N``` строчек начинаются на знак ```+``` (заключительное состояние) или ```-``` (не заключительное) и ```M``` чисел — состояний, куда перейдёт автомат.

Символы входного алфавита — строчные латинские буквы, начиная с ```a```.

Следует найти длину кратчайшей строки, которая различает эти автоматы (т.е. переводит один из них в заключительное, а другой — в не заключительное состояние).

Если автоматы описывают одинаковый язык, то следует вывести «```=```».

Пример. Для входных данных
```
5
5 1
+ 0 3 3 4 4
- 2 1 3 1 3
+ 0 3 3 1 4
+ 0 3 3 2 2
- 2 4 3 1 3
5 4
+ 0 2 1 4 4
+ 0 0 2 0 3
+ 0 0 2 0 2
+ 0 0 3 0 1
- 0 4 1 4 1
```
кратчайшая строка, различающая эти автоматы, будет иметь длину 3. Например, по строке cbd первый автомат перейдёт в незаключительное состояние 2, а второй — в заключительное 0.

Подсказка: рассмотрите кортеж ⟨q′, q″⟩, где q′ — состояние первого автомата, q″ — состояние второго автомата.

При написании программы на языке Java класс с функцией main должен называться DiffAutomata.
