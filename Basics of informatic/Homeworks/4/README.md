# Домашнее задание №4. Часть 1 #
# 1. Мемоизация #
Реализуйте рекурсивные вычисления с использованием оптимизационных техник — мемоизации результатов вычислений и отложенных вычислений.

**Важно!** Eсли в программе используются гигиенические макросы и эта программа будет выполнена в среде guile 1.8.x (в том числе на сервере тестирования), то следует подключить модуль поддержки таких макросов, написав в начале программы следующую строку:
```scheme
(use-syntax (ice-9 syncase))
```
Реализуйте процедуру ```memoized-factorial``` для вычисления факториала по рекурсивной формуле с мемоизацией результатов вычислений. Для мемоизации используйте ассоциативный список (словарь), который храните в статической переменной. Использовать для этой цели глобальную переменную *запрещается*.

Примеры вызова процедур сервером тестирования:
```scheme
(begin
  (display (memoized-factorial 10)) (newline)
  (display (memoized-factorial 50)) (newline))

3628800
30414093201713378043612608166064768844377641568960512000000000000
```
# 2. Отложенные вычисления #
Используя средства языка Scheme для отложенных вычислений, реализуйте средства для работы с бесконечными «ленивыми» точечными парами и списками:

* Гигиенический макрос ```(lazy-cons a b)```, конструирующий ленивую точечную пару вида ```(значение-a . обещание-вычислить-значение-b)```. Почему макрос в данном случае предпочтительнее процедуры?
* Процедуру ```(lazy-car p)```, возвращающую значение 1-го элемента «ленивой» точечной пары ```p```.
* Процедуру ```(lazy-cdr p)```, возвращающую значение 2-го элемента «ленивой» точечной пары ```p```.

На их основе определите:

* Процедуру ```(lazy-head xs k)```, возвращающую значение ```k``` первых элементов «ленивого» списка ```xs``` в виде списка.
* Процедуру ```(lazy-ref xs k)```, возвращающую значение ```k```-го элементa «ленивого» списка ```xs```.

Продемонстрируйте работу процедур на примере бесконечного списка натуральных чисел. Для этого определите процедуру-генератор ```(naturals start)```, возвращающую бесконечный «ленивый» список натуральных чисел, начиная с числа start.

Примеры вызова процедур сервером тестирования:
```scheme
(display (lazy-head (naturals 10) 12)) 
(10 11 12 13 14 15 16 17 18 19 20 21)
```
Реализуйте процедуру ```(lazy-factorial n)```, которая возвращает значение ```n!```, получая его из n-го элемента бесконечного списка факториалов.

Примеры вызова процедур сервером тестирования:
```scheme
(begin
  (display (lazy-factorial 10)) (newline)
  (display (lazy-factorial 50)) (newline))

3628800
30414093201713378043612608166064768844377641568960512000000000000
```
# «Ачивки» #
* Объяснить, как и почему работает следующий фрагмент кода:
```scheme
(((call-with-current-continuation
   (lambda (c) c))
  (lambda (x) x))
 'hello)
```
Можно догадаться, что этот код печатает ```hello```, но нужно объяснить почему. **+1 балл**.

* Написать макросы ```my-let``` и ```my-let*``` без использования эллипсисов (многоточий, ...) (и, конечно, встроенных ```let```, ```let*```, ```letrec```) **+1 балл** за оба.

* Объяснить, почему от перемены мест слагаемых меняется сумма в этом примере **(1 балл)**: 

![image](https://github.com/Kregiss/BMSTU_programming/assets/145288385/7bf6388c-d63f-433d-bb8b-147be78cffca)
